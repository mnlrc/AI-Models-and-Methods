import numpy as np
import itertools

def distance(cell: tuple[int, int], gem_position: tuple[int, int]):
    """Calculate Euclidean distance between the current cell and the gem position."""
    delta_x = cell[0] - gem_position[0]
    delta_y = cell[1] - gem_position[1]
    return np.sqrt((
        (delta_x ** 2) + 
        (delta_y ** 2)))

def vector_distance(vector1: list[int], vector2: list[int]):
    a = np.array(vector1)
    b = np.array(vector2)
    return np.sum(np.abs(a - b))

class BayesianNetwork:
    def __init__(self, grid_size: int, n_gems: int):
        self.grid_size = grid_size
        self.n_gems = n_gems
        self.G = np.ones((grid_size, grid_size)) / (grid_size * grid_size)
    
    def likelihood(self, current_cell: tuple[int, int], distances: list[int], gem_positions: list[tuple[int, int]]):
        """Compute likelihood of observing given distances, given gem positions."""
        ðœ† = 1 # hyperparameter set arbitrarly
        observations = []

        for gem_pos in gem_positions:
            observations.append(distance(current_cell, gem_pos))

        manhatan_distance = vector_distance(distances, observations)
        return np.exp(- manhatan_distance / ðœ†)

    
    def infer(self, cell: tuple[int, int], distances: list[int]):
        """Update beliefs using inference by enumeration over all possible gem positions."""
        
        """
        Comments generated by ChatGPT in the function below.
        """

        # Posterior matrix to accumulate marginal probabilities for each cell
        posterior = np.zeros((self.grid_size, self.grid_size))
        
        # Enumerate every possible combination of gem positions (joint configuration)
        # Example: for 2 gems, this iterates over all ((x1,y1), (x2,y2)) pairs
        for gems_positions in itertools.product(
                itertools.product(range(self.grid_size), repeat=2),
                repeat=self.n_gems):
            
            # ---- Likelihood term: P(D | G)
            # Measures how well this gem configuration explains the observed distances
            likelihood_value = self.likelihood(cell, distances, gems_positions)
            
            # ---- Prior term: P(G)
            # Assuming independence between gems, multiply individual prior probabilities
            prior_prob = 1.0
            for gem_pos in gems_positions:
                prior_prob *= self.G[gem_pos]
            
            # ---- Joint probability: P(D, G) = P(D | G) * P(G)
            joint_prob = likelihood_value * prior_prob
            
            # ---- Marginalization step:
            # For each gem position present in this configuration,
            # accumulate the joint probability into the posterior
            for gem_pos in gems_positions:
                posterior[gem_pos] += joint_prob
        
        # ---- Normalization:
        # Ensure that posterior sums to 1 across the entire grid
        total_prob = posterior.sum()
        if total_prob > 0:
            posterior /= total_prob
        else:
            # Fallback to uniform distribution if probabilities underflow
            posterior = np.ones((self.grid_size, self.grid_size)) / self.G.size
        
        # ---- Update beliefs:
        # Posterior becomes the new prior for the next observation
        self.G = posterior
    
    def get_belief_distribution(self):
        """Return current belief distribution (posterior)."""
        return self.G
